/*
 * Custom ZMK behavior: dual-release-combo
 *
 *    When the combo is triggered it presses BOTH bindings (slow + quick).
 *    When the FIRST key in the combo is released, the quick binding is
 *    released, but the slow binding remains active.  Once ALL keys of the
 *    combo have been released, the slow binding is also released.
 *
 * SPDX-License-Identifier: MIT
 */

#include <zephyr/device.h>
#include <zephyr/kernel.h>
#include <zephyr/init.h>

#include <zmk/behavior.h>
#include <zmk/keymap.h>
#include <zmk/event_manager.h>
#include <zmk/events/keycode_state_changed.h>

struct drc_config {
    struct zmk_behavior_binding slow_binding;
    struct zmk_behavior_binding quick_binding;
    /* key_positions array is generated by devicetree */
    const int32_t *key_positions;
    uint8_t num_positions;
};

struct drc_state {
    bool active;
    bool quick_released;
    uint8_t pressed_left; /* keys still pressed in the combo */
};

static int drc_binding_pressed(struct zmk_behavior_binding *binding,
                               struct zmk_behavior_binding_event event) {
    const struct device *dev = device_get_binding(binding->behavior_dev);
    struct drc_state *state = dev->data;
    const struct drc_config *cfg = dev->config;

    if (state->active) {
        return ZMK_BEHAVIOR_OPAQUE;
    }

    /* Press both bindings */
    zmk_behavior_keymap_binding_pressed(&cfg->slow_binding, event);
    zmk_behavior_keymap_binding_pressed(&cfg->quick_binding, event);

    state->active = true;
    state->quick_released = false;
    state->pressed_left = cfg->num_positions;

    return ZMK_BEHAVIOR_OPAQUE;
}

static int drc_binding_released(struct zmk_behavior_binding *binding,
                                struct zmk_behavior_binding_event event) {
    /* We purposely do nothing here – releases are handled by the listener */
    return ZMK_BEHAVIOR_OPAQUE;
}

/* ---------------- Event listener ----------------- */

static bool pos_belongs_to_combo(const struct drc_config *cfg, int32_t position) {
    for (uint8_t i = 0; i < cfg->num_positions; i++) {
        if (cfg->key_positions[i] == position) {
            return true;
        }
    }
    return false;
}

static int drc_event_listener(const struct zmk_event_header *eh) {
    if (!is_zmk_keycode_state_changed(eh)) {
        return 0;
    }

    const struct zmk_keycode_state_changed *ev = as_zmk_keycode_state_changed(eh);

    /* Iterate over all instances */
#define HANDLE_INSTANCE(idx, _dev)                                                         \
    {                                                                                      \
        const struct device *dev = DEVICE_DT_INST_GET(idx);                               \
        struct drc_state *state = dev->data;                                              \
        const struct drc_config *cfg = dev->config;                                       \
        if (!state->active) {                                                             \
            ;                                                                             \
        } else if (!pos_belongs_to_combo(cfg, ev->key_position)) {                        \
            ;                                                                             \
        } else {                                                                          \
            if (ev->state == false) { /* released */                                      \
                if (!state->quick_released) {                                             \
                    /* Release quick binding now */                                       \
                    struct zmk_behavior_binding_event dummy = {                           \
                        .timestamp = ev->timestamp,                                       \
                    };                                                                    \
                    zmk_behavior_keymap_binding_released(&cfg->quick_binding, dummy);      \
                    state->quick_released = true;                                         \
                }                                                                         \
                if (state->pressed_left > 0) {                                            \
                    state->pressed_left--;                                                \
                    if (state->pressed_left == 0) {                                       \
                        /* All keys released – release slow binding */                    \
                        struct zmk_behavior_binding_event dummy = {                       \
                            .timestamp = ev->timestamp,                                   \
                        };                                                                \
                        zmk_behavior_keymap_binding_released(&cfg->slow_binding, dummy);   \
                        state->active = false;                                            \
                    }                                                                     \
                }                                                                         \
            }                                                                             \
        }                                                                                  \
    }

    DT_INST_FOREACH_STATUS_OKAY(HANDLE_INSTANCE);

    return 0;
}

ZMK_LISTENER(dual_release_combo, drc_event_listener);
ZMK_SUBSCRIPTION(dual_release_combo, zmk_keycode_state_changed);

/* -------------- driver registration -------------- */

static const struct behavior_driver_api drc_driver_api = {
    .binding_pressed = drc_binding_pressed,
    .binding_released = drc_binding_released,
};

#define DRC_KEYPOS(node) DT_PROP(node, key_positions)

#define DUAL_RELEASE_COMBO_INST(n)                                                      \
    static struct drc_state drc_state_##n;                                             \
    static const int32_t keypos_##n[] = DT_INST_PROP(n, key_positions);                \
    static const struct drc_config drc_cfg_##n = {                                     \
        .slow_binding = {                                                              \
            .behavior_dev = DT_PHA_BY_IDX(DT_DRV_INST(n), bindings, 0, phandle),        \
            .param1 = DT_PROP_BY_IDX(DT_PHANDLE_BY_IDX(DT_DRV_INST(n), bindings, 0), reg, 0), \
        },                                                                             \
        .quick_binding = {                                                             \
            .behavior_dev = DT_PHA_BY_IDX(DT_DRV_INST(n), bindings, 1, phandle),        \
            .param1 = DT_PROP_BY_IDX(DT_PHANDLE_BY_IDX(DT_DRV_INST(n), bindings, 1), reg, 0), \
        },                                                                             \
        .key_positions = keypos_##n,                                                   \
        .num_positions = DT_INST_PROP_LEN(n, key_positions),                           \
    };                                                                                 \
    DEVICE_DT_INST_DEFINE(n, NULL, NULL, &drc_state_##n, &drc_cfg_##n, APPLICATION,    \
                          CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, &drc_driver_api);

DT_INST_FOREACH_STATUS_OKAY(DUAL_RELEASE_COMBO_INST) 